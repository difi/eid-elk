input {
  beats {
    port => 5044
  }
}

filter {

  # Parse message
  dissect {
    mapping => {
      "message" => '%{remote_host}	%{remote_logical_user}	%{remote_user}	[%{[@metadata][timestamp]}]	"%{verb} %{request} HTTP/%{httpversion}"	%{responsecode}	%{size}	%{responsetime_in_ms}	%{correlation_id}'
    }
  }

  # Generate ID for log message (change key as desired)
  fingerprint {
    source => ["@timestamp", "message"]
    target => "[@metadata][generated_id]"
    key => "my-key"
  }

  # Set @timestamp to timestamp of log message
  date {
    locale => "en"
    match => ["[@metadata][timestamp]", "dd/MMM/YYYY:HH:mm:ss Z"]
    timezone => "Europe/Oslo"
    target => "@timestamp"
  }

  mutate {
    # Set the short message field required by gelf
    add_field => {
      "short_message" => "%{message}"
    }

    # Make sure size is an integer (can be "-", which will become NaN)
    convert => {
      "size" => "integer"
    }
  }

  # Add day of the week, day of the month etc.
  ruby {
    id => "ruby_timestamp"
    code => "
      eventdate = DateTime.strptime(event.get('[@timestamp]').to_s,'%Y-%m-%dT%H:%M:%S.%L%Z')
      event.set('[timestamp_day_of_week]', eventdate.strftime('%A') ) # Name of day (Monday, ..., Sunday)
      event.set('[timestamp_month_of_year]', eventdate.strftime('%B') ) # Name of month (January, ..., December)
      event.set('[timestamp_day_of_month]', eventdate.strftime('%-d') ) # Day of the month (1, ..., 31)
      event.set('[timestamp_hour_of_day]', eventdate.strftime('%H') ) # Hour (00, ..., 23)
      event.set('[timestamp_minute_of_hour]', eventdate.strftime('%M') ) # Minute (00, 01, ..., 59)
      event.set('[timestamp_week_number]', eventdate.strftime('%W') ) # Week number (00, ..., 53)
      event.set('[timestamp_day_of_year]', eventdate.strftime('%j') ) # Day of the year (001, ..., 366)
      "
  }

}

output {
  gelf {
    host => "graylog"
    id => "access_logs_pipeline"
  }
}